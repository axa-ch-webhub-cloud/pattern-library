@import "../functions/strip-unit";
@import "../functions/breakpoint";
@import "../settings/grid";

/// Style the element when the viewport is at the given breakpoint or wider.
///
/// @param {string|number} $breakpoint - Either an existing breakpoint key or a valid CSS dimension.
/// @param {Map} $breakpoints [$grid-breakpoints] - The grid-tiers and associated breakpoints.
@mixin respond-up($breakpoint, $breakpoints: $grid-breakpoints) {
  $min: get-breakpoint($breakpoint, $breakpoints, up);

  @if (type_of($min) == number and $min > 0) {
    @media (min-width: $min) {
      @content;
    }
  } @else {
    @content;
  }
}

/// Style the element when the viewport is at the given breakpoint or smaller.
///
/// @param {string|number} $breakpoint - Either an existing breakpoint key or a valid CSS dimension.
/// @param {Map} $breakpoints [$grid-breakpoints] - The grid-tiers and associated breakpoints.
@mixin respond-down($breakpoint, $breakpoints: $grid-breakpoints) {
  $max: get-breakpoint($breakpoint, $breakpoints);

  @if (type_of($max) == number) {
    @media (max-width: $max) {
      @content;
    }
  } @else {
    @content;
  }
}

/// Style the element when the viewport is within the given breakpoints.
///
/// @param {string} $from - Either an existing breakpoint key.
/// @param {string} $to - Either an existing breakpoint key.
/// @param {Map} $breakpoints [$grid-breakpoints] - The grid-tiers and associated breakpoints.
@mixin respond-between($from, $to, $breakpoints: $grid-breakpoints) {
  @include respond-up($from, $breakpoints) {
    @include respond-down($to, $breakpoints) {
      @content;
    }
  }
}

/// Style the element when the viewport is at exactly the given breakpoint.
///
/// @param {string} $breakpoint - Either an existing breakpoint key.
/// @param {Map} $breakpoints [$grid-breakpoints] - The grid-tiers and associated breakpoints.
@mixin respond-only($breakpoint, $breakpoints: $grid-breakpoints) {
  @include respond-between($breakpoint, $breakpoint, $breakpoints: $grid-breakpoints) {
    @content;
  }
}

/// Style the element when the viewport is portrait.
@mixin respond-portrait() {
  @media (orientation: portrait) {
    @content;
  }
}

/// Style the element when the viewport is portrait.
@mixin respond-landscape() {
  @media (orientation: landscape) {
    @content;
  }
}

/// Style the element when the viewport has at least the given device pixel ration.
///
/// @param {number} $ratio [1] - The pixel device ration to match.
@mixin respond-pixel-ratio($ratio: 1) {
  @if (type_of($ratio) != number) {
    @error "$ratio #{$ratio} has to be a Number!";
  }

  @if (unit($ratio) == dppx) {
    $ratio: strip-unit($ratio);
  }

  @if (unitless($ratio)) {
    $ratio: $ratio * 96dpi;
  }

  @if (unit($ratio) != dpi) {
    @error "$ratio #{$ratio} has to be of unit dppx or unitless!";
  }

  @media (min-resolution: $ratio) {
    @content;
  }
}
